<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[keepalived]]></title>
    <url>%2F2018%2F09%2F01%2Fkeepalived%2F</url>
    <content type="text"><![CDATA[一、keepalived简介 Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。Keepalived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。所以，Keepalived一方面具有配置管理LVS的功能，同时还具有对LVS下面节点进行健康检查的功能，另一方面也可实现系统网络服务的高可用功能。 keepalived官网 http://www.keepalived.org 二、工作原理 Keepalived高可用服务对之间的故障切换转移，是通过 VRRP (Virtual Router Redundancy Protocol ,虚拟路由器冗余协议）来实现的。 在Keepalived服务正常工作时，主Master节点会不断地向备节点发送（多播的方式）心跳消息，用以告诉备Backup节点自己还活看，当主Master节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自主 Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的 IP资源及服务。而当主 Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源及服务，恢复到原来的备用角色。 那么，什么是VRRP呢？ VRRP ,全 称 Virtual Router Redundancy Protocol ,中文名为虚拟路由冗余协议 ，VRRP的出现就是为了解决静态踣甶的单点故障问题，VRRP是通过一种竞选机制来将路由的任务交给某台VRRP路由器的。Keepalived高可用对之间是通过VRRP通信的，因此，我们从 VRRP开始了解起：1) VRRP,全称 Virtual Router Redundancy Protocol,中文名为虚拟路由冗余协议，VRRP的出现是为了解决静态路由的单点故障。2) VRRP是通过一种竟选协议机制来将路由任务交给某台 VRRP路由器的。3) VRRP用 IP多播的方式（默认多播地址（224.0_0.18))实现高可用对之间通信。4) 工作时主节点发包，备节点接包，当备节点接收不到主节点发的数据包的时候，就启动接管程序接管主节点的开源。备节点可以有多个，通过优先级竞选，但一般 Keepalived系统运维工作中都是一对。5) VRRP使用了加密协议加密数据，但Keepalived官方目前还是推荐用明文的方式配置认证类型和密码。 Keepalived服务的工作原理： Keepalived高可用对之间是通过VRRP进行通信的，VRRP是遑过竞选机制来确定主备的，主的优先级高于备，因此，工作时主会优先获得所有的资源，备节点处于等待状态，当主挂了的时候，备节点就会接管主节点的资源，然后顶替主节点对外提供服务。 在 Keepalived服务对之间，只有作为主的服务器会一直发送VRRP广播包,告诉备它还活着，此时备不会抢占主，当主不可用时，即备监听不到主发送的广播包时，就会启动相关服务接管资源，保证业务的连续性.接管速度最快可以小于1秒。 三、基于lvs+dr模型使用keepalived实现web的高可用（单主）简易架构图如下： 1、配置准备 各节点时间必须同步 ntp, chrony 确保iptables及selinux不会成为阻碍 各节点之间可通过主机名互相通信（对KA并非必须）建议使用/etc/hosts文件实现 各节点之间的root用户可以基于密钥认证的ssh服务完成互相通信（对KA并非必须） 准备6台虚拟机，1台client,1台router，2台lvs，2台rs 2、配置rs两台RS服务器运行如下脚本实现 1234567891011121314151617181920212223242526272829303132333435#!/bin/bashvip=10.0.0.100mask='255.255.255.255'dev=lo:1rpm -q httpd &amp;&gt; /dev/null || yum -y install httpd &amp;&gt;/dev/nullservice httpd start &amp;&gt; /dev/null &amp;&amp; echo "The httpd Server is Ready!"echo "&lt;h1&gt;`hostname`&lt;/h1&gt;" &gt; /var/www/html/index.htmlcase $1 instart) echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce ifconfig $dev $vip netmask $mask #broadcast $vip up #route add -host $vip dev $dev echo "The RS Server is Ready!" ;;stop) ifconfig $dev down echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce echo "The RS Server is Canceled!" ;;*) echo "Usage: $(basename $0) start|stop" exit 1 ;;esac# 添加默认路由route add default gw 192.168.31.6 配置lvs1) lvs1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 安装keepalivedyum install keepalived -y# 修改配置文件vim /etc/keepalived/keepalived.conf ! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; root@localhost &#125; notification_email_from root@localhost smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id lvs1&#125;vrrp_instance VI_1 &#123; state MASTER interface eth1 virtual_router_id 50 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass magedu &#125; virtual_ipaddress &#123; 10.0.0.100/24 &#125;&#125;virtual_server 10.0.0.100 80 &#123; delay_loop 6 lb_algo wrr lb_kind DR protocol TCP real_server 192.168.31.27 80 &#123; weight 2 HTTP_GET &#123; url &#123; path / status_code 200 &#125; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125; real_server 192.168.31.37 80 &#123; weight 1 HTTP_GET &#123; url &#123; path / status_code 200 &#125; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125;&#125;# 启动keepalivedsystemctl start keepalived# 添加网关route add default gw 192.168.31.6 2) lvs2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 安装keepalivedyum install keepalived -y# 修改配置文件vim /etc/keepalived/keepalived.conf ! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; root@localhost &#125; notification_email_from root@localhost smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id lvs2&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens34 virtual_router_id 50 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass magedu &#125; virtual_ipaddress &#123; 10.0.0.100/24 &#125;&#125;virtual_server 10.0.0.100 80 &#123; delay_loop 6 lb_algo wrr lb_kind DR protocol TCP real_server 192.168.31.27 80 &#123; weight 2 HTTP_GET &#123; url &#123; path / status_code 200 &#125; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125; real_server 192.168.31.37 80 &#123; weight 1 HTTP_GET &#123; url &#123; path / status_code 200 &#125; connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125;&#125;# 启动keepalivedsystemctl start keepalived# 添加网关route add default gw 192.168.31.6 3) 配置router 123456# 修改内核参数vim /etc/sysctl.confnet.ipv4.ip_forward = 1sysctl -pip addr add 10.0.0.100/24 dev eth1 4) 客户端添加默认网关 1route add default gw 172.18.201.200 5) 客户端测试 1for i in &#123;1..100&#125;;do curl 10.0.0.100;sleep 1;done keepaived可以使用脚本进行资源监控keepalived调用外部的辅助脚本进行资源监控，并根据监控的结果状态能实现优先动态调整vrrp_script:自定义资源监控脚本，vrrp实例根据脚本返回值，公共定义，可被多个实例调用，定义在vrrp实例之外track_script:调用vrrp_script定义的脚本去监控资源，定义在实例之内，调用事先定义的vrrp_script 示例如下： 1234567891011121314151617181920212223242526272829# 定义脚本vim /app/check.sh[ -f /etc/keepalived/down ] &amp;&amp; exit 1 || exit 0 ## 配置文件中声明再调用vrrp_script chk_down &#123; script &quot;/app/check.sh&quot; interval 1 weight -20 &#125;vrrp_instance VI_1 &#123; state MASTER interface eth1 virtual_router_id 10 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass magedu &#125; virtual_ipaddress &#123; 10.0.0.100/24 &#125; track_script &#123; chk_down &#125;&#125;]]></content>
      <categories>
        <category>高可用集群</category>
      </categories>
      <tags>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX03]]></title>
    <url>%2F2018%2F08%2F30%2FNGINX03%2F</url>
    <content type="text"><![CDATA[ngx_http_access_module 可实现基于ip的访问控制功能 allow address |CIDR|unix:|all; deny address |CIDR|unix:|all; http, server, location, limit_except 自上而下检查，一旦匹配，将生效，条件严格的置前 示例： 1234567location / &#123;deny 192.168.1.1;allow 192.168.1.0/24;allow 10.1.1.0/16;allow 2001:0db8::/32;deny all;&#125; ngx_http_auth_basic_module 实现基于用户的访问控制，使用basic机制进行用户认证 1、auth_basic string | off;2、auth_basic_user_file file;1234location /admin/ &#123;auth_basic &quot;Admin Area&quot;;auth_basic_user_file /etc/nginx/.ngxpasswd;&#125; 用户口令文件： 1、明文文本：格式name:password:comment2、加密文本：由htpasswd命令实现 该命令由httpd-tools rpm包所提供 ngx_http_stub_status_module 用于输出nginx的基本状态信息Active connections:当前状态，活动状态的连接数accepts：统计总值，已经接受的客户端请求的总数handled：统计总值，已经处理完成的客户端请求的总数requests：统计总值，客户端发来的总的请求数Reading：当前状态，正在读取客户端请求报文首部的连接的连接数Writing：当前状态，正在向客户端发送响应报文过程中的连接数Waiting：当前状态，正在等待客户端发出请求的空闲连接数 示例12345location /status &#123;stub_status;allow 172.16.0.0/16;deny all;&#125; ngx_http_log_module 指定日志格式记录请求 log_format name string …; string可以使用nginx核心模块及其它模块内嵌的变量 access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; 示例： 1234log_format compression '$remote_addr-$remote_user [$time_local] ' '"$request" $status $bytes_sent ' '"$http_referer" "$http_user_agent" "$gzip_ratio"';access_log /spool/logs/nginx-access.log ompression buffer=32k; open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]; 缓存各日志文件相关的元数据信息max：缓存的最大文件描述符数量min_uses：在inactive指定的时长内访问大于等于此值方可被当作活动项inactive：非活动时长valid：验证缓存中各缓存项是否为活动项的时间间隔 ngx_http_gzip_module 用gzip方法压缩响应数据，节约带宽 1、gzip on | off; 启用或禁用gzip压缩 2、gzip_comp_level level; 压缩比由低到高：1 到 9 默认：13、gzip_disable regex …; 匹配到客户端浏览器不执行压缩 4、gzip_min_length length; 启用压缩功能的响应报文大小阈值 5、gzip_http_version 1.0 | 1.1; 设定启用压缩功能时，协议的最小版本 默认：1.1 6、gzip_buffers number size; 支持实现压缩功能时缓冲区数量及每个缓存区的大小 默认：32 4k 或 16 8k 7、gzip_types mime-type …; 指明仅对哪些类型的资源执行压缩操作；即压缩过滤器默认包含有text/html，不用显示指定，否则出错 8、gzip_vary on | off; 如果启用压缩，是否在响应报文首部插入“Vary: Accept-Encoding” 9、gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any …; nginx充当代理服务器时，对于后端服务器的响应报文，在何种条件下启用压缩功能 off：不启用压缩expired，no-cache, no-store，private：对后端服务器的响应报文首部Cache-Control值任何一个，启用压缩功能 示例： 12345gzip on;gzip_comp_level 6;gzip_min_length 64;gzip_proxied any;gzip_types text/xml text/css application/javascript; ngx_http_ssl_module1、ssl on | off 为指定虚拟机启用HTTPS protocol， 建议用listen指令代替 2、ssl_certificate file; 当前虚拟主机使用PEM格式的证书文件 3、ssl_certificate_key file; 当前虚拟主机上与其证书匹配的私钥文件 4、ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]; 支持ssl协议版本，默认为后三个 5、ssl_session_cache off | none | [builtin[:size]] [shared:name:size]; none: 通知客户端支持ssl session cache，但实际不支持builtin[:size]：使用OpenSSL内建缓存，为每worker进程私有[shared:name:size]：在各worker之间使用一个共享的缓存 6、ssl_session_timeout time; 客户端连接可以复用ssl session cache中缓存的有效时长，默认5m 示例： 12345678910server &#123;listen 443 ssl;server_name www.magedu.com;root /vhosts/ssl/htdocs;ssl on;ssl_certificate /etc/nginx/ssl/nginx.crt;ssl_certificate_key /etc/nginx/ssl/nginx.key;ssl_session_cache shared:sslcache:20m;ssl_session_timeout 10m;&#125; ngx_http_rewrite_module 将用户请求的URI基于PCRE regex所描述的模式进行检查，而后完成重定向替换例如：http://www.magedu.com –&gt; https://www.magedu.com/ 1、rewrite regex replacement [flag] 将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定的新的URI注意：如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查；被某条件规则替换完成后，会重新一轮的替换检查隐含有循环机制,但不超过10次；如果超过，提示500响应码，[flag]所表示的标志位用于控制此循环机制如果replacement是以http://或https://开头，则替换结果会直接以重向返回给客户端, 即永久重定向301 last：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环，不建议在location中使用 break：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环，建议在location中使用 redirect：临时重定向，重写完成后以临时重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；使用相对路径,或者http://或https://开头，状态码：302 permanent:重写完成后以永久重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求，状态码：301 2、return return code [text];return code URL;return URL;停止处理，并返回给客户端指定的响应码，对 301, 302, 303, 307, 308跳转到URL 3、rewrite_log on | off; 是否开启重写日志, 发送至error_log（notice level） 4、set $variable value; 用户自定义变量注意：变量定义和调用都要以$开头 5、if (condition) { … } 条件满足时，执行配置块中的配置指令；server, locationcondition：比较操作符： = 相同 != 不同 ~：模式匹配，区分字符大小写 ~*：模式匹配，不区分字符大小写 !~：模式不匹配，区分字符大小写 !~*：模式不匹配，不区分字符大小写 文件及目录存在性判断： -e, !-e 存在（包括文件，目录，软链接） -f, !-f 文件 -d, !-d 目录 -x, !-x 执行 ngx_http_referer_module 用来阻止Referer首部无有效值的请求访问，可防止盗链 1、valid_referers none|blocked|server_names|string …; 定义referer首部的合法可用值，不能匹配的将是非法值none：请求报文首部没有referer首部blocked：请求报文有referer首部，但无有效值server_names：参数，其可以有值作为主机名或主机名模式arbitrary_string：任意字符串，但可使用*作通配符regular expression：被指定的正则表达式模式匹配到的字符串,要使用~开头，例如： ~.*.magedu.com 示例： 12345valid_referers none block server_names *.magedu.com *.mageedu.com magedu.* mageedu.* ~\.magedu\.;if ($invalid_referer) &#123;return 403 http://www.magedu.com;&#125; ngx_http_proxy_module 转发请求至另一台主机 1、proxy_pass URL; Context:location, if in location, limit_except 注意：proxy_pass后面路径不带uri时，会将location的uri传递（附加）给后端主机 12345678server &#123; ... server_name HOSTNAME; location /uri/ &#123; proxy_pass http://host[:port]; 最后没有/ &#125; ...&#125; 上面示例：http://HOSTNAME/uri –&gt; http://host/uri如果上面示例中有 /，即：http://host[:port]/意味着：http://HOSTNAME/uri –&gt; http://host/ 即置换 proxy_pass后面的路径是一个uri时，其会将location的uri替换为proxy_pass的uri 12345678server &#123; ... server_name HOSTNAME; location /uri/ &#123; proxy_pass http://host/new_uri/; &#125; ...&#125; http://HOSTNAME/uri/ –&gt; http://host/new_uri/ 如果location定义其uri时使用了正则表达式的模式，则proxy_pass之后必须不能使用uri;用户请求时传递的uri将直接附加至后端服务器之后 12345678server &#123; ... server_name HOSTNAME; location ~|~* /uri/ &#123; proxy_pass http://host; 不能加/ &#125; ...&#125; http://HOSTNAME/uri/ –&gt; http://host/uri/ 2、proxy_set_header field value; 设定发往后端主机的请求报文的请求首部的值 Context: http, server, location12proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 请求报文的标准格式如下：X-Forwarded-For: client1, proxy1, proxy2 3、proxy_cache_path; 定义可用于proxy功能的缓存；Context:http 12proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]; 4、proxy_cache zone | off; 默认off 指明调用的缓存，或关闭缓存机制；Context:http, server, location 5、proxy_cache_key string;缓存中用于“键”的内容 默认值：proxy_cache_key $scheme$proxy_host$request_uri; 6、proxy_cache_valid [code …] time; 定义对特定响应码的响应内容的缓存时长,定义在http{…}中 示例:123proxy_cache_valid 200 302 10m;proxy_cache_valid 404 1m;ngx_http_proxy_module 示例：在http配置定义缓存信息 123proxy_cache_path /var/cache/nginx/proxy_cachelevels=1:1:1 keys_zone=proxycache:20m inactive=120s max_size=1g; 说明：proxycache:20m 指内存中缓存的大小，主要用于存放key和metadata（如：使用次数）max_size=1g 指磁盘存入文件内容的缓存空间最大值调用缓存功能，需要定义在相应的配置段，如server{…}；1234proxy_cache proxycache;proxy_cache_key $request_uri;proxy_cache_valid 200 302 301 1h;proxy_cache_valid any 1m; 7、proxy_cache_use_stale; proxy_cache_use_stale error | timeout | invalid_header | updating |http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off …在被代理的后端服务器出现哪种情况下，可直接使用过期的缓存响应客户端 8、proxy_cache_methods GET | HEAD | POST …; 对哪些客户端请求方法对应的响应进行缓存，GET和HEAD方法总是被缓存 9、proxy_hide_header field; 默认nginx在响应报文中不传递后端服务器的首部字段Date, Server, X-Pad, X-Accel-等，用于隐藏后端服务器特定的响应首部 10、proxy_connect_timeout time; 定义与后端服务器建立连接的超时时长，如超时会出现502错误，默认为60s，一般不建议超出75s 11、proxy_send_timeout time; 将请求发送给后端服务器的超时时长；默认为60s 12、proxy_read_timeout time; 等待后端服务器发送响应报文的超时时长，默认为60s ngx_http_headers_module模块 向由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值 1、add_header name value [always]; 添加自定义首部 123add_header X-Via $server_addr;add_header X-Cache $upstream_cache_status;add_header X-Accel $server_name; 2、add_trailer name value [always]; 添加自定义响应信息的尾部 ngx_http_fastcgi_module 转发请求到FastCGI服务器，不支持php模块方式 1、fastcgi_pass address;address为后端的fastcgi server的地址可用位置：location, if in location2、fastcgi_index name;fastcgi默认的主页资源示例：fastcgi_index index.php;3、fastcgi_param parameter value [if_not_empty];设置传递给 FastCGI服务器的参数值，可以是文本，变量或组合 示例1：1）在后端服务器先配置fpm server和mariadb-serve2）在前端nginx服务上做以下配置： 1234567location ~* \.php$ &#123;fastcgi_pass 后端fpm服务器IP:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME /app/php$fastcgi_script_name;include fastcgi_params;…&#125; 示例2：通过pm_status和ping来获取fpm server状态信息 12345location ~* ^/(pm_status|ping)$ &#123;include fastcgi_params;fastcgi_pass 后端fpm服务器IP:9000;fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;&#125; 4、fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size[inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time][manager_threshold=time] [loader_files=number] [loader_sleep=time][loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time][purger_threshold=time]; 定义fastcgi的缓存；path 缓存位置为磁盘上的文件系统 max_size=size 磁盘path路径中用于缓存数据的缓存空间上限 levels=levels：缓存目录的层级数量，以及每一级的目录数量 levels=ONE:TWO:THREE 示例：leves=1:2:2 keys_zone=name:size k/v映射的内存空间的名称及大小 inactive=time 非活动时长 5、fastcgi_cache zone | off; 调用指定的缓存空间来缓存数据 可用位置：http, server, location 6、fastcgi_cache_key string; 定义用作缓存项的key的字符串示例：fastcgi_cache_key $request_rui; 7、fastcgi_cache_methods GET | HEAD | POST …; 为哪些请求方法使用缓存 8、fastcgi_cache_min_uses number; 缓存空间中的缓存项在inactive定义的非活动时间内至少要被访问到此处所指定的次数方,可被认作活动项 9、fastcgi_keep_conn on | off; 收到后端服务器响应后，fastcgi服务器是否关闭连接，建议启用长连接 10、fastcgi_cache_valid [code …] time; 不同的响应码各自的缓存时长 示例： 123456789101112131415http &#123; fastcgi_cache_path /var/cache/nginx/fcgi_cache levels=1:2:1 keys_zone=fcgicache:20m inactive=120s; ... server &#123; location ~* \.php$ &#123; ... fastcgi_cache fcgicache; fastcgi_cache_key $request_uri; fastcgi_cache_valid 200 302 10m; fastcgi_cache_valid 301 1h; fastcgi_cache_valid any 1m; ... &#125; &#125;&#125; ngx_http_upstream_module 用于将多个服务器定义成服务器组，而由proxy_pass, fastcgi_pass等指令进行引用 1、upstream name { … } 定义后端服务器组，会引入一个新的上下文,默认调度算法是wrr Context: http 12345upstream httpdsrvs &#123; server ... server... ...&#125; 2、server address [parameters]; 在upstream上下文中server成员，以及相关的参数；Context:upstream address的表示格式： unix:/PATH/TO/SOME_SOCK_FILE IP[:PORT] HOSTNAME[:PORT] parameters： weight=number 权重，默认为1 max_conns 连接后端报务器最大并发活动连接数，1.11.5后支持 max_fails=number 失败尝试最大次数；超出此处指定的次数时，server将被标记为不可用,默认为1 fail_timeout=time 后端服务器标记为不可用状态的连接超时时长，默认10s backup 将服务器标记为“备用”，即所有服务器均不可用时才启用 down 标记为“不可用”，配合ip_hash使用，实现灰度发布 3、ip_hash 源地址hash调度方法 4、least_conn 最少连接调度算法 当server拥有不同的权重时其为wlc，当所有后端主机连接数相同时，则使用wrr，适用于长连接 5、hash key [consistent] 基于指定的key的hash表来实现对请求的调度，此处的key可以直接文本、变量或二者组合 作用：将请求分类，同一类请求将发往同一个upstream server，使用consistent参数，将使用ketama一致性hash算法，适用于后端是Cache服务器（如varnish）时使用 12hash $request_uri consistent;hash $remote_addr; 6、keepalive 连接数N; 为每个worker进程保留的空闲的长连接数量,可节约nginx端口，并减少连接管理的消耗 7、ngx_stream_core_module模块 模拟反代基于tcp或udp的服务连接，即工作于传输层的反代或调度器 示例：12345678910111213stream &#123; upstream mysqlsrvs &#123; server 192.168.0.10:3306; server 192.168.0.11:3306; hash $remote_addr consistent; &#125; server &#123; listen 172.16.100.100:3306; proxy_pass mysqlsrvs; proxy_timeout 60s; proxy_connect_timeout 10s; &#125; &#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX02]]></title>
    <url>%2F2018%2F08%2F29%2FNGINX02%2F</url>
    <content type="text"><![CDATA[Nginx介绍 Nginx：engine X ，2002年，开源，商业版 NGINX是免费，开源，高性能的HTTP和反向代理服务器，邮件代理服务器，通用TCP/UDP代理服务器 解决C10K问题（10K Connections） 官网：http://nginx.org 二次开发版：Tengine OpenResty（章亦春） 特性： 模块化设计，较好的扩展性 高可靠性 支持热部署：不停机更新配置文件，升级版本，更换日志文件 低内存消耗：10000个keep-alive连接模式下的非活动连接，仅需2.5M内存 event-driven,aio,mmap，sendfile 基本功能： 静态资源的web服务器 http协议反向代理服务器 pop3/imap4协议反向代理服务器 FastCGI(LNMP),uWSGI(python)等协议 模块化（非DSO），如zip，SSL模块 web服务相关的功能： 虚拟主机（server）支持 keep-alive 和管道连接访问日志（支持基于日志缓冲提高其性能）url rewirte路径别名基于IP及用户的访问控制支持速率限制及并发数限制重新配置和在线升级而无须中断客户的工作进程Memcached 的 GET 接口 Nginx架构 nginx的程序架构nginx的程序架构：master/worker结构 一个master进程： 负载加载和分析配置文件、管理worker进程、平滑升级 一个或多个worker进程 处理并响应用户请求 缓存相关的进程： cache loader：载入缓存对象 cache manager：管理缓存对象 nginx模块 nginx高度模块化，但其模块早期不支持DSO机制；1.9.11版本支持动态装载和卸载 模块分类： 核心模块：core module 标准模块： HTTP 模块:ngx_http_* HTTP Core modules 默认功能 HTTP Optional modules 需编译时指定 Mail 模块 ngx_mail_* Stream 模块 ngx_stream_* 第三方模块 nginx目录结构和命令ls /usr/local/nginx/ html是测试页，sbin是主程序s /usr/local/nginx/sbin/ nginx 只有一个程序文件ls /usr/local/nginx/html/ 50x.html index.html 测试网页 Nginx：默认为启动nginx -h 查看帮助选项 -V 查看版本和配置选项 -t 测试nginx语法错误 -c filename 指定配置文件(default: /etc/nginx/nginx.conf) -s signal 发送信号给master进程，signal：stop, quit, reopen, reload示例： nginx -s stop 停止nginx nginx -s reload 加载配置文件 -g directives 在命令行中指明全局指令 nginx配置 配置文件的组成部分： 主配置文件：nginx.conf 子配置文件 include conf.d/*.conf fastcgi， uwsgi，scgi等协议相关的配置文件 mime.types：支持的mime类型 主配置文件的配置指令： directive value [value2 …]; 注意： (1) 指令必须以分号结尾 (2) 支持使用配置变量 内建变量：由Nginx模块引入，可直接引用 自定义变量：由用户使用set命令定义 set variable_name value; 引用变量：$variable_name 主配置文件结构：四部1234567891011121314151617main block：主配置段，即全局配置段，对http,mail都有效event &#123;...&#125; 事件驱动相关的配置http &#123;...&#125; http/https 协议相关配置段mail &#123;...&#125; mail 协议相关配置段stream &#123;...&#125; stream 服务器相关配置段 http协议相关的配置结构1234567891011121314151617http &#123;...... 各server的公共配置server &#123; 每个server用于定义一个虚拟主机...&#125;server &#123; ...server_name 虚拟主机名root 主目录alias 路径别名location [OPERATOR] URL &#123; 指定URL的特性...if CONDITION &#123;...&#125;&#125; 帮助文档 http://nginx.org/en/docs/ 模块加载配置文件：/usr/share/nginx/modules/*.conf 指明要装载的动态模块路径: /usr/lib64/nginx/modules 性能优化相关的配置1、worker_processes number | auto worker进程的数量；通常应该为当前主机的cpu的物理核心数 2、worker_cpu_affinity cpumask … worker_cpu_affinity auto [cpumask] 提高缓存命中率 CPU MASK： 00000001：0号CPU 00000010：1号CPU 10000000：8号CPU worker_cpu_affinity 0001 0010 0100 1000; worker_cpu_affinity 0101 1010; 3、worker_priority number 指定worker进程的nice值，设定worker进程优先级：[-20,20] 4、worker_rlimit_nofile number worker进程所能够打开的文件数量上限,如65535 事件驱动相关的配置 worker_connections number 每个worker进程所能够打开的最大并发连接数数量，如10240总最大并发数：worker_processes * worker_connections use method 指明并发连接请求的处理方法,默认自动选择最优方法 use epoll; accept_mutex on | off 互斥 处理新的连接请求的方法；on指由各个worker轮流处理新请求，Off指每个新请求的到达都会通知(唤醒)所有的worker进程，但只有一个进程可获得连接，造成“惊群”，影响性能 调试和定位选项 daemon on|off 是否以守护进程方式运行nignx，默认是守护进程方式 master_process on|off是否以master/worker模型运行nginx；默认为on off 将不启动worker error_log file [level] 错误日志文件及其级别；出于调试需要，可设定为debug；但debug仅在编译时使用了“–with-debug”选项时才/有效 level:debug|info|notice|warn|error|crit|alter|emerg ngx_http_core_module1、server { … } 配置一个虚拟主机12345server &#123;listen address[:PORT]|PORT;server_name SERVER_NAME;root /PATH/TO/DOCUMENT_ROOT;&#125; 2、listen PORT|address[:port]|unix:/PATH/TO/SOCKET_FILE listen address[:port] [default_server] [ssl] [http2 | spdy] [backlog=number] [rcvbuf=size] [sndbuf=size] default_server 设定为默认虚拟主机 ssl 限制仅能够通过ssl连接提供服务 backlog=number 超过并发连接数后，新请求进入后援队列的长度 rcvbuf=size 接收缓冲区大小 sndbuf=size 发送缓冲区大小 注意：(1) 基于port；listen PORT; 指令监听在不同的端口(2) 基于ip的虚拟主机 listen IP:PORT; IP 地址不同(3) 基于hostname server_name fqdn; 指令指向不同的主机名 3、server_name name …; 虚拟主机的主机名称后可跟多个由空白字符分隔的字符串支持通配任意长度的任意字符 server_name *.magedu.com www.magedu.*支持~起始的字符做正则表达式模式匹配，性能原因慎用server_name ~^www\d+\.magedu\.com$说明： \d 表示 [0-9]匹配优先级机制从高到低：(1) 首先是字符串精确匹配 如：www.magedu.com(2) 左侧通配符 如：.magedu.com(3) 右侧通配符 如：www.magedu.(4) 正则表达式 如： ~^.*.magedu.com$(5) default_server 4、tcp_nodelay on | off; 在keepalived模式下的连接是否启用TCP_NODELAY选项当为off时，延迟发送，合并多个请求后再发送默认On时，不延迟发送可用于：http, server, location 5、sendfile on | off; 是否启用sendfile功能，在内核中封装报文直接发送,默认Off 6、server_tokens on | off | build | string 是否在响应报文的Server首部显示nginx版本 ngx_http_core_modu 7、root 设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径，可用于http, server, location, if in location 1234server &#123;...root /data/www/vhost1;&#125; 8、location [ = | ~ | ~* | ^~ ] uri { … } location @name { … } 在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；ngnix会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置 示例：123456server &#123;... server_name www.magedu.com; location /images/ &#123; root /data/imgs/; &#125;&#125; ^~： 对URI的最左边部分做匹配检查，不区分字符大小写~： 对URI做正则表达式模式匹配，区分字符大小写~*： 对URI做正则表达式模式匹配，不区分字符大小写不带符号：匹配起始于此uri的所有的uri匹配优先级从高到低：=, ^~, ～/～*, 不带符号 9、alias path; 路径别名，文档映射的另一种机制；仅能用于location上下文 示例：http://www.magedu.com/bbs/index.php123456location /bbs/ &#123;alias /web/forum/;&#125; --&gt; /web/forum/index.htmllocation /bbs/ &#123;root /web/forum/;&#125; --&gt; /web/forum/bbs/index.html 注意：location中使用root指令和alias指令的意义不同(a) root，给定的路径对应于location中的/uri/左侧的/(b) alias，给定的路径对应于location中的/uri/右侧的/ 10、index file …; 指定默认网页文件，注意：ngx_http_index_module模块 11、error_page code … [=[response]] uri; 模块：ngx_http_core_module定义错误页，以指定的响应状态码进行响应可用位置：http, server, location, if in locationerror_page 404 /404.htmlerror_page 404 =200 /404.html 12、try_files file … uri; try_files file … =code;按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向。最后一个参数是回退URI且必须存在，否则会出现内部500错误 123456location /images/ &#123; try_files $uri /images/default.gif; &#125;location / &#123; try_files $uri $uri/index.html $uri.html =404; &#125; 13、keepalive_timeout timeout [header_timeout]; 设定保持连接超时时长，0表示禁止长连接，默认为75s 14、keepalive_requests number; 在一次长连接上所允许请求的资源的最大数量,默认为100 15、keepalive_disable none | browser … 对哪种浏览器禁用长连接 16、send_timeout time; 向客户端发送响应报文的超时时长，此处是指两次写操作之间的间隔时长，而非整个响应过程的传输时长 17、client_body_buffer_size size; 用于接收每个客户端请求报文的body部分的缓冲区大小；默认为16k；超出此大小时，其将被暂存到磁盘上的由下面client_body_temp_path指令所定义的位置 18、client_body_temp_path path [level1 [level2 [level3]]]; 设定存储客户端请求报文的body部分的临时存储路径及子目录结构和数量目录名为16进制的数字；client_body_temp_path /var/tmp/client_body 1 2 21 1级目录占1位16进制，即2^4=16个目录 0-f2 2级目录占2位16进制，即2^8=256个目录 00-ff2 3级目录占2位16进制，即2^8=256个目录 00-ff 19、limit_rate rate; 限制响应给客户端的传输速率，单位是bytes/second,默认值0表示无限制 20、limit_except method … { … }，仅用于location 限制客户端使用除了指定的请求方法之外的其它方法method:GET, HEAD, POST, PUT, DELETE，MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, PATCH 1234limit_except GET &#123;allow 192.168.1.0/24;deny all;&#125; 除了GET和HEAD 之外其它方法仅允许192.168.1.0/24网段主机使用 21、aio on | off | threads[=pool]; 是否启用aio功能 22、directio size | off; 当文件大于等于给定大小时，例如directio 4m，同步（直接）写磁盘，而非写缓存 23、open_file_cache off; open_file_cache max=N [inactive=time];nginx可以缓存以下三种信息：(1) 文件元数据：文件的描述符、文件大小和最近一次的修改时间(2) 打开的目录结构(3) 没有找到的或者没有权限访问的文件的相关信息max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现管理,inactive=time：缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于open_file_cache_min_uses指令所指定的次数的缓存项即为非活动项，将被删除 24、open_file_cache_errors on | off; 是否缓存查找时发生错误的文件一类的信息,默认值为off 25、open_file_cache_min_uses number; open_file_cache指令的inactive参数指定的时长内，至少被命中此处指定的次数方可被归类为活动项,默认值为1 26、open_file_cache_valid time; 缓存项有效性的检查频率,默认值为60s]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX01]]></title>
    <url>%2F2018%2F08%2F28%2FNGINX01%2F</url>
    <content type="text"><![CDATA[I/O介绍I/O: 网络I: 本质是socket读取 磁盘IO: 硬盘上的读写 每次IO,都要经由两个阶段 将数据从磁盘文件先加载至内核内存空间（缓冲区），等待数据准备完成，时间较长 将数据从内核缓冲区复制到用户空间的进程的内存中，时间较短 I/O模型 同步/异步：关注的是消息通信机制 同步：synchronous，调用者等待被调用者返回消息，才能继续执行 asynchronous，被调用者通过状态、通知或回调机制主动通知调用者被调用者的运行状态 阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态 阻塞：blocking，指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起 非阻塞：nonblocking，指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成，最终的调用结果返回之前，调用者不会被挂起 I/O模型：阻塞型、非阻塞型、复用型、信号驱动型、异步 同步阻塞模型 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞 用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作 用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够 同步非阻塞模型 用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制 整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源 是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性 IO多路复用模型 多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上 用户首先将需要进行IO操作添加到select中，继续执行做其他的工作（异步），同时等待select系统调用返回。当数据到达时，IO被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。而不像阻塞IO那种，一次只能监控一个IO 虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率 IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，而非真正的异步IO. 多路I/O复用 IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，就通知该进程 IO多路复用适用如下场合： 当客户端处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用 当一个客户端同时处理多个套接字时，此情况可能的但很少出现 当一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般也要用到I/O复用 当一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用 当一个服务器要处理多个服务或多个协议，一般要使用I/O复用 信号驱动IO模型 信号驱动IO：signal-drivenI/O 用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当有IO操作准备就绪时，由内核通知触发一个SIGIO信号处理程序执行，然后将用户进程所需要的数据从内核空间拷贝到用户空间 此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知 该模型并不常用 异步IO模型 异步IO与信号驱动IO最主要的区别是信号驱动IO是由内核通知何时可以进行IO操作，而异步IO则是由内核告诉用户线程IO操作何时完成。信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后，内核直接通知用户线程可以进行后续操作了 相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中） 五种IO模型 I/O模型的具体实现 Select：Linux实现对应，I/O复用模型，BSD4.2最早实现 Poll：Linux实现，对应I/O复用模型，System V unix最早实现 Epoll：Linux实现，对应I/O复用模型，具有信号驱动I/O模型的某些特性 Kqueue：FreeBSD实现，对应I/O复用模型，具有信号驱动I/O模型某些特性. /dev/poll：SUN的Solaris实现，对应I/O复用模型，具有信号驱动I/O模型的某些特性 Iocp Windows实现，对应第5种（异步I/O）模型 select/poll/epoll select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 哈希表 IO效率 每次调用都进行线性时间复杂度为O(n) 每次调用都进行线性遍历时间复杂度为O(n) 时间通知方式，fd就绪系统注册的回调函数就会被调用，将就绪的fd放到rdlist里面，时间复杂度为O(1) 最大连接数 1024(X86)或2048(X64) 无上限 无上限 fd拷贝 每次调用select,都需要把fd集合从用户状态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用expoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 Select:POSIX所规定，目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理 缺点 单个进程可监视的fd数量被限制，即能监听端口的数量有限cat /proc/sys/fs/file-max 对socket是线性扫描，即采用轮询的方法，效率较低 select 采取了内存拷贝方法来实现内核将FD消息通知给用户空间，这样一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大 poll 本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态 其没有最大连接数的限制，原因是它是基于链表来存储的 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义 poll特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd 边缘触发：只通知一次 epoll：在Linux 2.6内核中提出的select和poll的增强版本支持水平触发LT和边缘触发ET，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次 使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知 优点: 没有最大并发连接的限制：能打开的FD的上限远大于1024(1G的内存能监听约10万个端口) 效率提升：非轮询的方式，不会随着FD数目的增加而效率下降；只有活跃可用的FD才会调用callback函数，即epoll最大的优点就在于它只管理“活跃”的连接，而跟连接总数无关 内存拷贝，利用mmap(Memory Mapping)加速与内核空间的消息传递；即epoll使用mmap减少复制开销]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP服务2]]></title>
    <url>%2F2018%2F08%2F27%2FFTP%E6%9C%8D%E5%8A%A12%2F</url>
    <content type="text"><![CDATA[实现基于文件验证的vsftpd虚拟用户1、创建用户数据库文件12345678vim /etc/vsftpd/vusers.txt wang wangpass mage magepasscd /etc/vsftpd/db_load -T -t hash -f vusers.txt vusers.dbchmod 600 vusers.db 2、创建用户和访问FTP目录12useradd -d /var/ftproot -s /sbin/nologin vuserchmod +rx /var/ftproot/ Centos7 还需要执行以下操作： 123chmod -w /var/ftproot/mkdir /var/ftproot/uploadsetfacl -m u:vuser:rwx /var/ftproot/upload 3、创建pam配置文件123vim /etc/pam.d/vsftpd.dbauth required pam_userdb.so db=/etc/vsftpd/vusersaccount required pam_userdb.so db=/etc/vsftpd/vusers 4、指定pam配置文件1234vim /etc/vsftpd/vsftpd.confguest_enable=YES guest_username=vuserpam_service_name=vsftpd.db 5、SELinux设置： 禁用SELinux 或者 setsebool -P ftpd_full_access 1 6、虚拟用户建立独立的配置文件123mdkir /etc/vsftpd/vusers.d/ 创建配置文件存放的路径vim /etc/vsftpd/vsftpd.confuser_config_dir=/etc/vsftpd/vusers.d/ cd /etc/vsftpd/vusers.d/ 进入此目录 7、允许wang用户可读写，其它用户只读vim wang 创建各用户自已的配置文件 123anon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES vim mage 创建各用户自已的配置文件 1local_root=/ftproot 登录目录改变至指定的目录 实现基于MYSQL验证的vsftpd虚拟用户 说明：本实验在两台CentOS主机上实现，一台做为FTP服务器，一台做数据库服务器 1、在数据库服务器上安装包： Centos7：在数据库服务器上安装 123yum –y install mariadb-serversystemctl start mariadb.servicesystemctl enable mariadb Centos6：在数据库服务器上安装 1yum –y install mysql-server 在FTP服务器上安装vsftpd和pam_mysql包 12centos6：pam_mysql由epel6的源中提供yum install vsftpd pam_mysql centos7：无对应rpm包，需手动编译安装 123456789yum -y groupinstall &quot;Development Tools&quot;yum -y install mariadb-devel pam-devel vsftpd下载pam_mysql-0.7RC1.tar.gzftp://172.16.0.1/pub/Sources/sources/pam/tar xvf pam_mysql-0.7RC1.tar.gzcd pam_mysql-0.7RC1/./configure --with-pam-mods-dir=/lib64/security --with-mysql=/usr --with-pam=/usrmakemake install 2、在数据库服务器上创建虚拟用户账号 建立存储虚拟用户数据库和连接的数据库用户 12mysql&gt; CREATE DATABASE vsftpd;mysql&gt; SHOW DATABASES; ftp服务和mysql不在同一主机：12mysql&gt; GRANT SELECT ON vsftpd.* TO vsftpd@'172.16.%.%' IDENTIFIED BY 'magedu'; ftp服务和mysql在同一主机：12345mysql&gt; GRANT SELECT ON vsftpd.* TO vsftpd@localhost IDENTIFIED BY 'magedu';mysql&gt; GRANT SELECT ON vsftpd.* TO vsftpd@'127.0.0.1' IDENTIFIED BY 'magedu';mysql&gt; FLUSH PRIVILEGES; 准备相关表 12345678mysql&gt; USE vsftpd;Mysql&gt; SHOW TABLES;mysql&gt; CREATE TABLE users (id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,name CHAR(50) BINARY NOT NULL,password CHAR(48) BINARY NOT NULL);mysql&gt;DESC users; 测试连接12mysql -uvsftpd -h 172.16.200.200 -pmagedumysql&gt; SHOW DATABASES; 添加虚拟用户 根据需要添加所需要的用户，为了安全应该使用PASSWORD函数加密其密码后存储 123456mysql&gt;DESC users;mysql&gt; INSERT INTO users(name,password) values(‘wang',password('magedu'));mysql&gt; INSERT INTO users(name,password) values(‘mage',password('magedu'));mysql&gt; SELECT * FROM users; 3、在FTP服务器上配置vsftpd服务 在FTP服务器上建立pam认证所需文件 123vi /etc/pam.d/vsftpd.mysql 添加如下两行auth required pam_mysql.so user=vsftpd passwd=magedu host=mysqlserver db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2account required pam_mysql.so user=vsftpd passwd=magedu host=mysqlserver db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2 crypt是加密方式，0表示不加密，1表示crypt(3)加密，2表示使用mysql password()函数加密，3表示md5加密，4表示sha1加密 auth 表示认证account 验证账号密码正常使用required 表示认证要通过pam_mysql.so模块是默认的相对路径，是相对/lib64/security/路径而言，也可以写绝对路径；后面为给此模块传递的参数user=vsftpd为登录mysql的用户passwd=magedu 登录mysql的的密码host=mysqlserver mysql服务器的主机名或ip地址db=vsftpd 指定连接msyql的数据库名称table=users 指定连接数据库中的表名usercolumn=name 当做用户名的字段passwdcolumn=password 当做用户名字段的密码crypt=2 密码的加密方式为mysql password()函数加密 建立相应用户和修改vsftpd配置文件，使其适应mysql认证 建立虚拟用户映射的系统用户及对应的目录1234useradd -s /sbin/nologin -d /var/ftproot vuserchmod 555 /var/ftproot centos7 需除去ftp根目录的写权限mkdir /var/ftproot/&#123;upload,pub&#125;setfacl –m u:vuser:rwx /var/ftproot/upload 确保/etc/vsftpd.conf中已经启用了以下选项1anonymous_enable=YES 添加下面两项12guest_enable=YESguest_username=vuser 修改下面一项，原系统用户无法登录1pam_service_name=vsftpd.mysql 4、启动vsftpd服务12service vsftpd start;systemctl start vsftpdchkconfig vsftpd on;systemctl enable vsftpd 查看端口开启情况1netstat -tnlp |grep :21 5、Selinux相关设置：在FTP服务器上执行1234restorecon -R /lib64/securitysetsebool -P ftpd_connect_db 1setsebool -P ftp_home_dir 1chcon -R -t public_content_rw_t /var/ftproot/ 6、测试：利用FTP客户端工具,以虚拟用户登录验证结果1tail /var/log/secure 7、在FTP服务器上配置虚拟用户具有不同的访问权限vsftpd可以在配置文件目录中为每个用户提供单独的配置文件以定义其ftp服务访问权限，每个虚拟用户的配置文件名同虚拟用户的用户名。配置文件目录可以是任意未使用目录，只需要在vsftpd.conf指定其路径及名称即可 配置vsftpd为虚拟用户使用配置文件目录 123vim /etc/vsftpd/vsftpd.conf添加如下选项user_config_dir=/etc/vsftpd/vusers_config 创建所需要目录，并为虚拟用户提供配置文件 123mkdir /etc/vsftpd/vusers_config/cd /etc/vsftpd/vusers_config/touch wang mage 配置虚拟用户的访问权限 虚拟用户对vsftpd服务的访问权限是通过匿名用户的相关指令进行的。如果需要让用户wang具有上传文件的权限，可以修改/etc/vsftpd/vusers_config/wang文件，在里面添加如下选项并设置为YES即可,只读则设为NO 注意：需确保对应的映射用户对于文件系统有写权限1234anon_upload_enable=&#123;YES|NO&#125;anon_mkdir_write_enable=&#123;YES|NO&#125;anon_other_write_enable=&#123;YES|NO&#125;local_root=/ftproot 登录目录改变至指定的目录]]></content>
      <categories>
        <category>service</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables3]]></title>
    <url>%2F2018%2F08%2F27%2Fiptables3%2F</url>
    <content type="text"><![CDATA[iptables命令匹配条件 基本：通用的，PARAMETERS 扩展：需加载模块，MATCH EXTENTIONS 1、 基本匹配条件：无需加载模块，由iptables/netfilter自行提供 -s,--source address[/mask]: 源ip地址或范围-d, --destination address[/mask][,...]：目标IP地址或范围-p, --protocol protocol:指定协议，可使用数字如0（all）protocol: tcp, udp, icmp, icmpv6, udplite,esp, ah, sctp, mh or all 参看：/etc/protocols-i, --in-interface name: 报文流入的接口；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链-o, --out-interface name: 报文流出的接口；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链 2、 扩展匹配条件：需要加载扩展模块（/usr/lib64/xtables/*.so），方可生效 查看帮助 man iptables-extensions 隐式扩展：在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块 [!] –source-port, –sport port[:port]：匹配报文源端口,可为端口范围 [!] –destination-port,–dport port[:port]：匹配报文目标端口,可为范围 [!] –tcp-flags mask compmask 需检查的标志位列表，用,分隔 例如 SYN,ACK,FIN,RSTcomp 在mask列表中必须为1的标志位列表，无指定则必须为0，用,分隔示例：–tcp-flags SYN,ACK,FIN,RST SYN 表示要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0–tcp-flags SYN,ACK,FIN,RST SYN,ACK–tcp-flags ALL ALL–tcp_flags ALL NONE–syn：用于匹配第一次握手,相当于：–tcp-flags SYN,ACK,FIN,RST SYN udp[!] –source-port, –sport port[:port]：匹配报文的源端口；可以是端口范围[!] –destination-port,–dport port[:port]：匹配报文的目标端口；可以是端口范围 icmp[!] –icmp-type {type[/code]|typename}type/code 0/0 echo-reply icmp应答 8/0 echo-request icmp请求 显式扩展：：必须使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块 [-m matchname [per-match-options]]处理动作：-j targetname [per-target-option 简单： ACCEPT，DROP 扩展： REJECT：–reject-with:icmp-port-unreachable默认 RETURN：返回调用链 REDIRECT：端口重定向 LOG：记录日志， dmesgMARK：做防火墙标记 DNAT：目标地址转换 SNAT：源地址转换 MASQUERADE：地址伪装 或者自定义链 使用帮助： CentOS 6: man iptables CentOS 7: man iptables-extensions 1、 multiport扩展 以离散方式定义多端口匹配,最多指定15个端口 [!] –source-ports,–sports port[,port|,port:port]…指定多个源端口 [!] –destination-ports,–dportsport[,port|,port:port]…指定多个目标端口 [!] –ports port[,port|,port:port]…多个源或目标端口 示例：1iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp -m multiport --dports 20:22,80 -j ACCEPT 2、 iprange扩展 指明连续的（但一般不是整个网络）ip地址范围 [!] –src-range from[-to] 源IP地址范围 [!] –dst-range from[-to] 目标IP地址范围 示例：1iptables -A INPUT -d 172.16.1.100 -p tcp --dport 80 -m iprange --srcrange 172.16.1.5-172.16.1.10 -j DROP 3、 mac扩展 指明源MAC地址 适用于：PREROUTING, FORWARD，INPUT chains [!] –mac-source XX:XX:XX:XX:XX:XX示例：12iptables -A INPUT -s 172.16.0.100 -m mac --mac-source 00:50:56:12:34:56 -j ACCEPT iptables -A INPUT -s 172.16.0.100 -j REJECT 4、 string扩展 对报文中的应用层数据做字符串模式匹配检测 –algo {bm|kmp}：字符串匹配检测算法 bm：Boyer-Moore kmp：Knuth-Pratt-Morris –from offset 开始偏移 –to offset 结束偏移 [!] –string pattern：要检测的字符串模式 [!] –hex-string pattern：要检测字符串模式，16进制格式 示例： 1iptables -A OUTPUT -s 172.16.100.10 -d 0/0 -p tcp --sport 80 -m string --algo bm --string “google&quot; -j REJECT 5、 time 扩展 根据将报文到达的时间与指定的时间范围进行匹配 –datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] 日期 –datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] –timestart hh:mm[:ss] 时间 –timestop hh:mm[:ss] [!] –monthdays day[,day…] 每个月的几号 [!] –weekdays day[,day…] 星期几 –kerneltz：内核时区，不建议使用，CentOS7系统默认为UTC 注意： centos6 不支持kerneltz ，–localtz指定本地时区(默认)示例：1iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp --dport 80 -m time --timestart 14:30 --timestop 18:30 --weekdays Sat,Sun --kerneltz -j DROP 6、 connlimit扩展 根据每客户端IP做并发连接数数量匹配 可防止CC(Challenge Collapsar挑战黑洞)攻击 –connlimit-upto n：连接的数量小于等于n时匹配 –connlimit-above n：连接的数量大于n时匹配 通常分别与默认的拒绝或允许策略配合使用 示例：1iptables -A INPUT -d 172.16.100.10 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT 7、 limit扩展 基于收发报文的速率做匹配 令牌桶过滤器 –limit rate[/second|/minute|/hour|/day] –limit-burst number示例：12iptables -I INPUT -d 172.16.100.10 -p icmp --icmp-type 8 -m limit --limit 10/minute -- limit-burst 5 -j ACCEPT iptables -I INPUT 2 -p icmp -j REJECT 8、 state扩展 状态有如下几种： NEW：新发出请求；连接追踪信息库中不存在此连接的相关信息条目，因此，将其识别为第一次发出的请求 ESTABLISHED：NEW状态之后，连接追踪信息库中为其建立的条目失效之前期间内所进行的通信状态 RELATED：新发起的但与已有连接相关联的连接，如：ftp协议中的数据连接与命令连接之间的关系 INVALID：无效的连接，如flag标记不正确 UNTRACKED：未进行追踪的连接，如raw表中关闭追踪 示例 12iptables -A INPUT -d 172.16.1.10 -p tcp -m multiport --dports 22,80 -m state -- state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -s 172.16.1.10 -p tcp -m multiport --sports 22,80 -m state -- state ESTABLISHED -j ACCEPT 已经追踪到的并记录下来的连接信息库 /proc/net/nf_conntrack调整连接追踪功能所能够容纳的最大连接数量 /proc/sys/net/nf_conntrack_max不同的协议的连接追踪时长 /proc/sys/net/netfilter/注意：CentOS7 需要加载模块： modprobe nf_conntrackiptables的链接跟踪表最大容量为/proc/sys/net/nf_conntrack_max，各种状态的超时链接会从表中删除；当模板满载时，后续连接可能会超时解决方法两个： (1) 加大nf_conntrack_max 值 123vi /etc/sysctl.confnet.nf_conntrack_max = 393216net.netfilter.nf_conntrack_max = 393216 (2) 降低 nf_conntrack timeout时间123456vi /etc/sysctl.confnet.netfilter.nf_conntrack_tcp_timeout_established = 300net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120iptables -t nat -L -n 开启被动模式的ftp服务1、装载ftp连接追踪的专用模块：跟踪模块路径：/lib/modules/kernelversion/kernel/net/netfilter123vim /etc/sysconfig/iptables-config 配置文件IPTABLES_MODULES=&quot;nf_conntrack_ftp&quot;modproble nf_conntrack_ftp 2、放行请求报文：命令连接：NEW, ESTABLISHED数据连接：RELATED, ESTABLISHED12iptables –I INPUT -d LocalIP -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A INPUT -d LocalIP -p tcp --dport 21 -m state --state NEW -j ACCEPT 3、放行响应报文：1iptables -I OUTPUT -s LocalIP -p tcp -m state --state ESTABLISHED -j ACCEPT 具体命令12345678910yum install vsftpdsystemctl start vsftpdmodprobe nf_conntrack_ftpiptables -Fiptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A INPUT -p tcp --dport 21 -m state --state NEW -j ACCEPTiptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPTiptables -P INPUT DROPiptables -P OUTPUT DROPiptables -vnL 规则优化 1、 安全放行所有入站和出站的状态为ESTABLISHED状态连接2、 谨慎放行入站的新请求3、 有特殊目的限制访问功能，要在放行规则之前加以拒绝4、 同类规则（访问同一应用），匹配范围小的放在前面，用于特殊处理5、 不同类的规则（访问不同应用），匹配范围大的放在前面6、 应该将那些可由一条规则能够描述的多个规则合并为一条7、 设置默认策略，建议白名单（只放行特定连接） 1） iptables -P，不建议 2） 建议在规则的最后定义规则做为默认策略 保存规则保存规则至指定的文件CentOS 6service iptables save将规则覆盖保存至/etc/sysconfig/iptables文件中CentOS 7 可用下面方法保存规则iptables-save &gt; /PATH/TO/SOME_RULES_FILE CentOS 6：service iptables restart 会自动从/etc/sysconfig/iptables 重新载入规则CentOS 7 重新载入预存规则文件中规则：iptables-restore &lt; /PATH/FROM/SOME_RULES_FILE-n, –noflush：不清除原有规则-t, –test：仅分析生成规则集，但不提交 开机自动重载规则文件中的规则： 用脚本保存各iptables命令；让此脚本开机后自动运行/etc/rc.d/rc.local文件中添加脚本路径 /PATH/TO/SOME_SCRIPT_FILE 用规则文件保存各规则，开机时自动载入此规则文件中的规则/etc/rc.d/rc.local文件添加 iptables-restore &lt; /PATH/FROM/IPTABLES_RULES_FILE 自定义Unit File，进行iptables-restore 网络防火墙iptables/netfilter网络防火墙： (1) 充当网关 (2) 使用filter表的FORWARD链 注意的问题： (1) 请求-响应报文均会经由FORWARD链，要注意规则的方向性 (2) 如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行 实验：实现内网ping外网，外网无法Ping内网ip_forward功能启用 方法一：123iptables -P FORWARD DROPiptables -t filter -A FORWARD -s 192.168.31.0/24 -p icmp --icmp-type 8 -j ACCEPT iptables -t filter -A FORWARD -d 192.168.31.0/24 -p icmp --icmp-type 0 -j ACCEPT 方法二：123iptables -A FORWARD -m state --state ESTABLISHED -j ACCEPTiptables -t filter -A FORWARD -s 192.168.31.0/24 -p icmp --icmp-type 8 -j ACCEPT iptables -A FORWARD -j REJECT 实验：实现从内网可访问外网，外网可访问内网的HTTP和SSH服务1234iptables -P FORWARD DROPiptables -A FORWARD -m state --state ESTABLISHED -j ACCEPTiptables -A FORWARD -s 192.168.31.0/24 -m state --state NEW -j ACCEPTiptables -A FORWARD -d 192.168.31.0/24 -p tcp -m multiport --dports 22,80 -m state --state NEW -j ACCEPT 实验：实现外网可访问内网的单个FTP服务器1234iptables -P FORWARD DROPmodprobe nf_conntrack_ftpiptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A FORWARD -p tcp --dport 21 -d 192.168.31.17 -m state --state NEW -j ACCEPT 实验：实现从内网可访问外网的特定服务FTP，HTTP，HTTPS1234iptables -P FORWARD DROPmodprobe nf_conntrack_ftpiptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A FORWARD -p tcp -m multiport --dports 21,80,443 -s 192.168.31.0/24 -m state --state NEW -j ACCEPT 实验：自定义链实现从内网可访问外网的特定服务FTP,HTTP,HTTPS,DNS,MYSQL12345678iptables -P FORWARD DROPiptables -N WEBiptables -A WEB -s 192.168.31.0/24 -p tcp -m multiport --dports 21,80,443,53 -j ACCEPTiptables -A WEB -s 192.168.31.0/24 -p udp --dport 53 -j ACCEPTiptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -A FORWARD -j WEBiptables -vnL 修改自定义链，增加MYSQL的访问 1iptables -R WEB 1 -p tcp -m multiport --dports 21,80,443,3306 -s 192.168.31.0/24 -j ACCEPT 删除自定义链 1234iptables -vnLiptables -D FORWARD 2iptables -F WEBiptables -X WEB 实验：SNAT DNAT 端口转发123iptables -t nat -A POSTROUTING -s 192.168.31.0/24 -j SNAT --to-source 172.18.0.123iptables -t nat -A POSTROUTING -s 192.168.31.0/24 -j MASQUERADEiptables -t nat -A PREROUTING -d 172.18.0.123 -p tcp --dport 80 -j DNAT --to-destination 192.168.31.17]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP服务]]></title>
    <url>%2F2018%2F08%2F20%2FFTP%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[文件传输协议FTP1、基于C/S架构2、双通道协议：数据和命令连接3、数据传输格式：二进制（默认）和文本4、两种模式：服务器角度 主动(POST style)：服务器主动连接命令(控制):客户端：随机port—&gt;服务器：tcp21数据:客户端:随机port&lt;—服务器:tcp20 被动(PASV style): 客户端主动连接命令(控制):客户端:随机port—&gt;服务器: tcp21数据:客户端：随机port—&gt;服务器:随机port 5、服务器被动模式数据端口示例： 命令通道建立连接的回话中，会协商数据通道要使用的端口 227(状态码) Entering Passive Mode (ip ,224,59)服务器数据端口为：224*256+59 FTP软件介绍1、FTP服务器： Wu-ftpd,Proftpd,Pureftpd,ServU,IIS(微软) vsftpd:Very Secure FTP Daemon,CentOS默认FTP服务器，高速而且稳定 2、客户端软件： ftp,lftp,lftpget,wget,curl lftp -A ftpserver port -A 主动模式 -p 被动模式 lftp -u username ftpserver lftp username@ftpserver lftpget ftp://ftpserver/pub/file filezilla(windows),CuteFTP,FlashFXP,LeapFtp IE浏览器中输入 ftp://username:password@ftpserver FTP服务1、状态码： 1XX:信息 125：数据连接打开 2XX:成功类状态 200：命令OK 230：登录成功 3XX:补充类 331：用户名OK 4XX:客户端错误 425：不能打开数据连接 5XX:服务器错误 530：不能登录 2、用户认证: 匿名用户：ftp,anonymous,对应Linux用户ftp 系统用户：Linux用户，用户/etc/passwd,密码/etc/shadow 虚拟用户：特定服务的专用用户，独立的用户密码文件 nsswitch:network service switch pam:用户认证 /lib64/security /etc/pam.d/ /etc/pam.conf vsftp服务1、由vsftp包提供，不再由xinetd管理，用户认证配置文件：/etc/pam.d/vsftpd2、服务脚本：/usr/lib/systemd/system/vsftpd.service,/etc/rc.d/init.d/vsftpd3、配置文件：/etc/vsftpd/vsftpd.conf - 格式：option=value - 注意：= 前后不要有空格 4、匿名用户（映射为系统用户ftp ）共享文件位置：/var/ftp5、系统用户共享文件位置：用户家目录6、虚拟用户共享文件位置：为其映射的系统用户的家目录 vsftpd服务配置1、命令端口 1listen_port=21 2、主动模式端口 12connect_from_port_20=YES 主动模式端口为20ftp_data_port=20 （默认） 指定主动模式的端口 3、被动模式端口范围 linux 客户端默认使用被动模式windows 客户端默认使用主动模式 12pasv_min_port=6000 0为随机分配pasv_max_port=6010 4、使用当地时间 1use_localtime=YES 使用当地时间（默认为NO，使用GMT） 5、匿名用户 1234567anonymous_enable=YES 支持匿名用户no_anon_password=YES(默认NO) 匿名用户略过口令检查anon_world_readable_only (默认YES) 只能下载全部读的文件anon_upload_enable=YES 匿名上传，注意:文件系统权限anon_mkdir_write_enable=YES 匿名建目录anon_umask=077 指定匿名上传文件的umaskanon_other_write_enable=YES 可删除和修改上传的文件 指定上传文件的默认的所有者和权限 123chown_uploads=YES(默认NO)chown_username=wangchown_upload_mode=0644 6、linux系统用户 123456guest_enable=YES 所有系统用户都映射成guest用户guest_username=ftp 配合上面选项才生效，指定guest用户local_enable=YES 是否允许linux用户登录write_enable-YES 允许linux用户上传文件local_umask=022 指定系统用户上传文件的默认权限local_root=/ftproot guest 用户登录所在目录 7、禁锢所有系统用户在家目录中 1chroot_local_user=YES（默认NO，不禁锢）禁锢系统用户 8、禁锢或不禁锢特定的系统用户在家目录中，与上面设置功能相反 1234chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list当chroot_local_user=YES时，则chroot_list中用户不禁锢当chroot_local_user=NO时，则chroot_list中用户禁锢 9、vsftpd日志 12dual_log_enable=YES 使用vsftpd日志格式，默认不启用 vsftpd_log_file=/var/log/vsftpd.log（默认）可自动生成 10、登录提示信息 12ftpd_banner=“welcome to mage ftp server&quot;banner_file=/etc/vsftpd/ftpbanner.txt 优先上面项生效 11、目录访问提示信息 12dirmessage_enable=YES (默认)message_file=.message 默认信息存放在指定目录下.message 12、使用pam(Pluggable AuthenticationModules)完成用户认证 12pam_service_name=vsftppam配置文件:/etc/pam.d/vsftpd/etc/vsftpd/ftpusers 默认文件中用户拒绝登录 13、是否启用控制用户登录的列表文件 123userlist_enable=YES 默认有此设置userlist_deny=YES(默认值) 黑名单,不提示口令，NO为白名单userlist_file=/etc/vsftpd/users_list 此为默认值 14、vsftpd服务指定用户身份运行 1nopriv_user=nobody (默认值) 15、连接数限制 12max_clients=0 最大并发连接数max_per_ip=0 每个IP同时发起的最大连接数 16、传输速率：字节/秒 12anon_max_rate=0 匿名用户的最大传输速率local_max_rate=0 本地用户的最大传输速率 17、连接时间：秒为单位 1234connect_timeout=60 主动模式数据连接超时时长accept_timeout=60 被动模式数据连接超时时长data_connection_timeout=300 数据连接无数据输超时时长idle_session_timeout=60 无命令操作超时时长 18、优先以文本方式传输 12ascii_upload_enable=YESascii_download_enable=YES 实现基于SSL的FTPS1、 查看是否支持SSL 1ldd `which vsftpd` 查看到libssl.so 2、 创建自签名证书 123cd /etc/pki/tls/certs/make vsftpd.pemopenssl x509 -in vsftpd.pem -noout –text 3、 配置vsftpd服务支持SSL：/etc/vsftpd/vsftpd.conf 12345ssl_enable=YES 启用SSLallow_anon_ssl=NO 匿名不支持SSLforce_local_logins_ssl=YES 本地用户登录加密force_local_data_ssl=YES 本地用户数据传输加密rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem 4、 用filezilla等工具测试 vsftpd虚拟用户1、虚拟用户： 所有虚拟用户会统一映射为一个指定的系统帐号：访问共享位置，即为此系统帐号的家目录各虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定 2、虚拟用户帐号的存储方式： 文件：编辑文本文件，此文件需要被编码为hash格式 奇数行为用户名，偶数行为密码 db_load -T -t hash -f vusers.txt vusers.db 关系型数据库中的表中： 3、实时查询数据库完成用户认证 mysql库：pam要依赖于pam-mysql /lib64/security/pam_mysql.so /usr/share/doc/pam_mysql-0.7/README]]></content>
      <categories>
        <category>service</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables2]]></title>
    <url>%2F2018%2F08%2F19%2Fiptables2%2F</url>
    <content type="text"><![CDATA[内核中数据包的传输过程 当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去 如果数据包就是进入本机的，数据包就会到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出 如果数据包是要转发出去的，且内核允许转发，数据包就会到达FORWARD链，然后到达POSTROUTING链输出 iptables规则 规则rule：根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作作出处理 1、匹配条件：默认为与条件，同时满足 基本匹配：IP,端口,TCP的Flags（SYN,ACK等）扩展匹配：通过复杂高级功能匹配 2、处理动作：称为target，跳转目标 内建处理动作：ACCEPT,DROP,REJECT,SNAT,DNATMASQUERADE,MARK,LOG… 自定义处理动作：自定义chain，利用分类管理复杂情形 3、规则要添加在链上，才生效；添加在自定义上不会自动生效 链chain： 1、内置链：每个内置链对应于一个钩子函数2、自定义链：用于对内置链进行扩展或补充，可实现更灵活的规则组织管理机制；只有Hook钩子调用自定义链时，才生效 iptables添加要点 iptables规则添加时考量点 1、要实现那种功能：判断添加在那张表上2、报文流经的路径：判断添加在哪个链上3、报文的流向：判断源和目的4、匹配规则：业务需要 链上规则的次序，即为检查的次序，因此隐含一定的法则 1、同类规则（访问同一应用），匹配范围小的放上面2、不同类规则（访问不同应用），匹配到报文频率较大的放上面3、将那些可由一条规则描述的多个规则合并为一个4、设置默认策略 避免自己定义的规则和系统默认的冲突，建议关闭系统的防火墙Centos 7 系统环境12systmectl stop firewalld.service 关闭防火墙systemctl disable firewalld.service 设置开机不启动 Centos 6 系统环境12service iptables stop 关闭防火墙chkconfig iptables off 设置开机不启动 iptables命令简单实例 规则格式1iptables [-t table] SUBCOMMAND chain [-m matchname [per-matchoptions]] -j targetname [per-target-options] -t table:raw,mangle,nat,[filter]默认链管理 -N：new，自定义一条新的规则链-X：delete，删除自定义的空的规则链-P：Policy，设置默认策略；对filter表中的链默认为ACCEPT，可修改DROP-E：重命名自定义链；引用计数不为0的自定义链不能够重命名，也不能被删除 规则查看 -L：list, 列出指定鏈上的所有规则，本选项须置后-n：numberic，以数字格式显示地址和端口号-v：verbose，详细信息-vv 更详细-x：exactly，显示计数器结果的精确值,而非单位转换后的易读值–line-numbers：显示规则的序号常用组合：–vnL;–vvnxL; –line-numbers-S selected,以iptables-save 命令格式显示链上规则 规则管理 -A：append，追加-I：insert, 插入，要指明插入至的规则编号，默认为第一条-D：delete，删除 (1) 指明规则序号 (2) 指明规则本身-R：replace，替换指定链上的指定规则编号-F：flush，清空指定的规则链-Z：zero，置零 iptables的每条规则都有两个计数器 (1) 匹配到的报文的个数 (2) 匹配到的所有报文的大小之和]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>iptables2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables1]]></title>
    <url>%2F2018%2F08%2F18%2Fiptables1%2F</url>
    <content type="text"><![CDATA[一、iptables的基本认识 1、Netfilter组件 内核空间，集成在linux内核中 扩展各种网络服务的结构化底层框架 内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则 由信息过滤表（table）组成，包含控制IP包处理的规则集（rules），规则被分组放在链（chain）上 2、 三种报文流向： 流入本机：PREROUTING –&gt; INPUT–&gt;用户空间进程 流出本机：用户空间进程 –&gt;OUTPUT–&gt; POSTROUTING 转发：PREROUTING –&gt; FORWARD –&gt; POSTROUTING 二、iptables的组成1、iptables由五个表和五个链以及一些规则组成 五个表table：filter、nat、mangle、raw、security filter表:过滤规则表，根据预定义的规则过滤符合条件的数据包 nat表:network address translation 地址转换规则表 mangle:修改数据标记位规则表 Raw:关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度 Security：此表用于强制访问控制（MAC）网络规则，由Linux安全模块（如SELinux）实现 优先级由高到低的顺序为:security –&gt;raw–&gt;mangle–&gt;nat–&gt;filter 2、五个内置链chain INPUT OUTPUT FORWARD PREROUTING POSTROUTING 三、Netfilter表和链对应关系 四、数据包过滤匹配流程]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
</search>
